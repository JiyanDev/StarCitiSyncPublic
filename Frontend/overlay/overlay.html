<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: transparent !important;
      background: transparent !important;
      -webkit-app-region: no-drag;
      font-family: 'Vera Mono', monospace;
      color: #ffa94d;
      font-size: 20px;
      height: 100vh;
      overflow: hidden;
    }

    @font-face {
      font-family: 'Vera Mono';
      src: url('./fonts/VeraMono.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }

    #overlay-timer {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 8px 16px;
      background-color: rgba(20, 42, 58, 0.6);
      border-radius: 8px;
    }

    #latest-kills {
      opacity: 0.00; 
      transition: opacity 1.0s;
      position: absolute;
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
      background-color: transparent !important;
      border-radius: 8px;
      padding: 12px 16px;
      min-width: 300px;
      min-height: 5.5em;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 4px;
    }

    #latest-kills.visible {
      opacity: 1;
    }

    .kill-event {
      font-size: 16px;
      line-height: 1.2;
      white-space: nowrap;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.4s cubic-bezier(0.4,0,0.2,1), transform 0.4s cubic-bezier(0.4,0,0.2,1);
    }
    .kill-event.show {
      opacity: 1;
      transform: translateY(0);
    }

    #latest-stall-actors:empty,
    #latest-stall-actors.hidden {
      display: none !important;
    }

    #latest-stall-actors {
      position: absolute;
      right: 20px;
      top: 20px;
      background: rgba(20, 42, 58, 0.85);
      border-radius: 8px;
      padding: 12px 18px;
      min-width: 260px;
      color: #fff;
      font-size: 16px;
      font-family: 'Vera Mono', monospace;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      gap: 4px;
      opacity: 1;
      z-index: 10;
    }
    .stall-actor {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 0;
      border-bottom: 1px solid rgba(255,255,255,0.07);
    }
    .stall-actor:last-child {
      border-bottom: none;
    }
    .stall-actor .player {
      font-weight: bold;
      color: #ffa94d;
    }
    .stall-actor .length {
      color: #4dc9ff;
      font-variant-numeric: tabular-nums;
    }
  </style>
</head>
<body>
  <div id="overlay-timer">00:00:00</div>
  <div id="latest-kills"></div>
  <div id="latest-stall-actors"></div>

  <script>
    function getLatestKillsSetting() {
      return localStorage.getItem('latestKillsSetting') || 'default';
    }
    
    window.session.onTimeUpdate((timeStr) => {
      document.getElementById('overlay-timer').innerText = timeStr;
    });


    
    function prettifyEntityName(name) {
      if (!name) return "";

      name = name.replace(/[_-]\d{8,}$/, '');

      let parts = name.split(/[_-]+/);

      // (ex. PU, AEGS, MISC, DRAK, CNOU, CRUS, ANVL)
      while (parts.length && /^[A-Z0-9]{2,6}$/.test(parts[0])) {
        parts.shift();
      }

      while (parts.length && /^(Pilots?|Human|Enemy|GroundCombat|NPC|Contestedzones|PU)$/.test(parts[0])) {
        parts.shift();
      }

      name = parts.join(' ');

      name = name.replace(/\b\w/g, c => c.toUpperCase());

      if (name.length > 32) {
        name = name.slice(0, 29) + '...';
      }

      return name.trim();
    }

    function getKillIcon(damageType, weapon) {
      if (damageType) {
        switch (damageType) {
          case "Suicide": return "ðŸ’€";
          case "SelfDestruct": return "ðŸ’£";
          case "VehicleDestruction": return "ðŸš€";
          case "Bullet": return "ðŸ”«";
          case "Explosion": return "ðŸ’¥";
          case "Collision": return "ðŸ’¥";
          case "Crash": return "ðŸ’¥";
          default: return "âžœ";
        }
      }
      switch (weapon) {
        case "Combat": return "âš”ï¸";
        case "SelfDestruct": return "ðŸ’£";
        case "Collision": return "ðŸ’¥";
        default: return "âžœ";
      }
    }
    
    function updateOverlayTimerVisibility() {
      const overlayTimer = document.getElementById('overlay-timer');
      if (overlayTimer) {
        const visible = localStorage.getItem('showOverlayTimer') !== 'false';
        overlayTimer.style.display = visible ? '' : 'none';
      }
    }

    updateOverlayTimerVisibility();

    window.addEventListener('storage', (e) => {
      if (e.key === 'showOverlayTimer') {
        updateOverlayTimerVisibility();
      }
    });

    const stallActorState = {};
    window.session.onLatestStallActors((stallActors) => {
      const container = document.getElementById('latest-stall-actors');
      container.innerHTML = '';
      if (!stallActors || stallActors.length === 0) {
        container.classList.add('hidden');
        return;
      }
      container.classList.remove('hidden');

      stallActors.forEach(actor => {
        const prev = stallActorState[actor.Player];
        const div = document.createElement('div');
        div.className = 'stall-actor';
        let startValue = typeof prev === 'number' ? prev : 0;
        div.innerHTML = `<span class="player">${actor.Player}</span><span class="length">${startValue.toFixed(1)}m</span>`;
        container.appendChild(div);
        if (Math.abs(startValue - actor.Length) > 0.05) {
          let current = startValue;
          const target = actor.Length;
          const step = (target - current) / 60;
          const lengthSpan = div.querySelector('.length');
          let i = 0;
          lengthSpan.style.transition = 'color 0.2s';
          lengthSpan.style.color = '#ff4d4d'; 
          function animate() {
            if (i < 30) {
              current += step;
              lengthSpan.textContent = `${current.toFixed(1)}m`;
              i++;
              requestAnimationFrame(animate);
            } else {
              lengthSpan.textContent = `${target.toFixed(1)}m`;
              lengthSpan.style.color = '#4dc9ff';
            }
          }
          animate();
        } else {
          const lengthSpan = div.querySelector('.length');
          lengthSpan.textContent = `${actor.Length.toFixed(1)}m`;
          lengthSpan.style.color = '#4dc9ff';
        }
        stallActorState[actor.Player] = actor.Length;
      });

      Object.keys(stallActorState).forEach(player => {
        if (!stallActors.find(a => a.Player === player)) {
          delete stallActorState[player];
        }
      });
    });

    window.session.onLatestKills((killEvents) => {
      window._lastKillEvents = killEvents;
      const container = document.getElementById('latest-kills');
      const setting = getLatestKillsSetting();
      
      // Hantera "off"
      if (setting === 'off') {
        container.style.display = 'none';
        return;
      } else {
        container.style.display = '';
      }

      const prevIds = Array.from(container.children).map(div => div.dataset.eventid);
      container.innerHTML = '';
      let shouldShow = false;

  killEvents.forEach((event, idx) => {
      const div = document.createElement('div');
      div.className = 'kill-event';

      if (event.EntityType === 'Vehicle') {
        div.style.color = '#4dc9ff';
      } else if (event.EntityType === 'person') {
        div.style.color = '#ffa94d';
      }
      div.dataset.eventid = event.Id;

      const dmgIcon = getKillIcon(event.DamageType, event.Weapon);
      div.textContent = `${prettifyEntityName(event.Killer)} ${dmgIcon} ${prettifyEntityName(event.EntityName)}`;

      container.appendChild(div);
      if (!prevIds.includes(String(event.Id)) || killEvents.length > prevIds.length) {
        shouldShow = true;
        setTimeout(() => {
          div.classList.add('show');
        }, 30 + idx * 60);
      } else {
        div.classList.add('show');
      }
    });

    if (setting === 'active') {
      if (killEvents.length > 0) {
        container.classList.add('visible');
      } else {
        container.classList.remove('visible');
      }
      clearTimeout(container._hideTimeout);
    } 
    else if (setting === 'default') {
      let seconds = parseInt(localStorage.getItem('latestKillsSeconds'), 10);
      if (isNaN(seconds) || seconds < 2 || seconds > 30) seconds = 6;

      if (shouldShow && killEvents.length > 0) {
        container.classList.add('visible');
        clearTimeout(container._hideTimeout);
        container._hideTimeout = setTimeout(() => {
          container.classList.remove('visible');
        }, seconds * 1000);
      }
      if (killEvents.length === 0) {
        container.classList.remove('visible');
        clearTimeout(container._hideTimeout);
      }
    }
  });

  window.addEventListener('storage', (e) => {
    if (e.key === 'latestKillsSetting') {
      const container = document.getElementById('latest-kills');
      const setting = getLatestKillsSetting();
      if (window._lastKillEvents) {
        // Re-run the kill handler to update UI
        window.session.onLatestKills(window._lastKillEvents);

        // If switching to default and there are kills, start timeout
        if (setting === 'default' && window._lastKillEvents.length > 0) {
          let seconds = parseInt(localStorage.getItem('latestKillsSeconds'), 10);
          if (isNaN(seconds) || seconds < 2 || seconds > 30) seconds = 6;
          clearTimeout(container._hideTimeout);
          container._hideTimeout = setTimeout(() => {
            container.classList.remove('visible');
          }, seconds * 1000);
        }
      }
    }
  });
  </script>
</body>
</html>
